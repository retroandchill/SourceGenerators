using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Microsoft.CodeAnalysis;
using Retro.SourceGeneratorUtilities.Core.Attributes;
using Retro.SourceGeneratorUtilities.Core.Types;
#nullable enable

namespace {{Namespace}};

public record {{AttributeName}}Info{{#HasParentClass}} : {{ParentAttribute}}Info{{/HasParentClass}} {

  {{#Properties}}
  public required {{Type}} {{Name}} { get; init; }
  {{/Properties}}
}

public static class {{AttributeName}}InfoExtensions {

  public static {{AttributeName}}Info Get{{AttributeName}}Info(this AttributeData data, Compilation compilation) {
    return data.TryGet{{AttributeName}}Info(compilation, out var info) ? info : throw new InvalidOperationException("Cannot create {{AttributeName}}Info");
  }  

  public static bool TryGet{{AttributeName}}Info(this AttributeData data, Compilation compilation, [NotNullWhen(true)] out {{AttributeName}}Info? info) {
    var args = data.ConstructorArguments;

    if (data.AttributeClass is null) {
      info = null;
      return false;
    }

    {{#ChildClasses}}
    if (!data.AttributeClass.IsOfType(typeof({{FullName}}))) {
      if ({{FullName}}InfoExtensions.TryGet{{Name}}Info(data, compilation, out var childInfo)) {
        info = childInfo;
        return true;
      } else {
        info = null;
        return false;
      }
    }
    {{/ChildClasses}}

    if (!data.AttributeClass.IsSameType(typeof({{AttributeName}}))) {
      info = null;
      return false;
    }

    {{#Constructors}}
    if (data.HasMatchingConstructor({{#Parameters}}typeof({{NonNullableType}}){{^IsLast}}, {{/IsLast}}{{/Parameters}})) {
      {{#Parameters}}
      var {{Name}} = data.ConstructorArguments[{{Index}}].GetTypedValue<{{Type}}>();
      {{/Parameters}}
    
      var namedArguments = data.NamedArguments.ToDictionary();
    
      info = new {{../AttributeName}}Info {
        {{#Assignments}}
        {{PropertyName}} = {{#HasSetter}}namedArguments.TryGetValue("{{PropertyName}}", out var value{{PropertyName}}) ? value{{PropertyName}}.GetTypedValue<{{PropertyType}}>() : {{/HasSetter}}{{Right}},
        {{/Assignments}}
      };
      return true;
    }
    
    {{/Constructors}}

    info = null;
    return false;
  }

  public static IEnumerable<{{AttributeName}}Info> Get{{AttributeName}}Infos(this IEnumerable<AttributeData> attributeDatas, Compilation compilation) {
    foreach (var data in attributeDatas) {
      if (data.TryGet{{AttributeName}}Info(compilation, out var info)) {
        yield return info;
      }
    }
  }

}