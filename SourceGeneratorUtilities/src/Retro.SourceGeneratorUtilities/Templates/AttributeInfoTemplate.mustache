using System;
using System.Linq;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Retro.SourceGeneratorUtilities.Core.Attributes;
using Retro.SourceGeneratorUtilities.Core.Types;
#nullable enable

namespace {{Namespace}};

public record {{AttributeName}}Info{{#HasParentClass}} : {{ParentAttribute}}Info{{/HasParentClass}} {

  {{#Properties}}
  public required {{Type}} {{Name}} { get; init; }
  {{/Properties}}
}

public static class {{AttributeName}}InfoExtensions {

  public static {{AttributeName}}Info New(this AttributeInfo<{{AttributeName}}> info, Compilation compilation) {
    var args = info.Data.ConstructorArguments;

    {{#Constructors}}
    if (info.Data.HasMatchingConstructor({{#Parameters}}typeof({{NonNullableType}}){{^IsLast}}, {{/IsLast}}{{/Parameters}})) {
      {{#Parameters}}
      var {{Name}} = info.Data.ConstructorArguments[{{Index}}].GetTypedValue<{{Type}}>();
      {{/Parameters}}
    
      var namedArguments = info.Data.NamedArguments.ToDictionary();
    
      return new {{../AttributeName}}Info {
        {{#Assignments}}
        {{PropertyName}} = {{#HasSetter}}namedArguments.TryGetValue("{{PropertyName}}", out var value{{PropertyName}}) ? value{{PropertyName}}.GetTypedValue<{{PropertyType}}>() : {{/HasSetter}}{{Right}},
        {{/Assignments}}
      };
    }
    
    {{/Constructors}}
    throw new InvalidOperationException("Cannot create {{AttributeName}}Info"); 
  }

  public static IEnumerable<{{AttributeName}}Info> New(this IEnumerable<AttributeInfo<{{AttributeName}}>> infos, Compilation compilation) {
    return infos.Select(info => info.New(compilation));
  }

}