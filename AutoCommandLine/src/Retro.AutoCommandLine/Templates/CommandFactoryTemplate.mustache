using System;
using System.CommandLine;
using Retro.AutoCommandLine.Core.Handlers;

namespace {{Namespace}};

public static class {{ClassName}}Factory {

  public static Command Create() {
    {{#IsRootCommand}}
    var command = new RootCommand({{#HasDescription}}{{Description}}{{/HasDescription}});  
    {{/IsRootCommand}}
    {{^IsRootCommand}}
    var command = new Command("{{CommandName}}"{{#HasDescription}}, {{Description}}{{/HasDescription}});
    {{/IsRootCommand}}

    {{#Options}}
    var {{Name}}{{Wrapper}} = new {{Wrapper}}<{{Type}}>({{#IsOption}}[{{#Aliases}}"{{Name}}"{{^IsLast}}, {{/IsLast}}{{/Aliases}}]{{/IsOption}}{{^IsOption}}"{{DisplayName}}"{{/IsOption}}) {
      {{#HasDescription}}
      Description = {{Description}},
      {{/HasDescription}}
      {{#IsRequired}}
      IsRequired = true,
      {{/IsRequired}}
    };
    {{/Options}}

    {{#Options}}
    command.Add{{Wrapper}}({{Name}}{{Wrapper}});
    {{/Options}}

    {{#Handler}}
    command.SetHandler({{#IsAsync}}async {{/IsAsync}}ctx => {
      var context = (ICommandLineContext) ctx.BindingContext.GetService(typeof(ICommandLineContext));
      if (context is null) {
        throw new InvalidOperationException("No command line context was found");
      }  
      var binder = context.GetBinder<{{../ClassName}}>();
      var cmd = binder.Bind(ctx);
      
      {{#ReturnsValue}}ctx.ExitCode = {{/ReturnsValue}}{{#IsAsync}}await {{/IsAsync}}cmd.{{Name}}({{#HasCancellationToken}}ctx.GetCancellationToken(){{/HasCancellationToken}});
    });
    {{/Handler}}

    return command;
  }

}